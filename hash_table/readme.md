#### 散列冲突
- 开放寻址法
  - 如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入
  - 线性探测(Linear Probing)
    - 当往散列表中插入数据时，如果某个数据经过散列函数之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止
  - 二次探测(Quadratic probing)
    - 线性探测每次探测的步长是1，那它探测的下标序列就是hash(key) + 0, hash(key) + 1, hash(key) + 2 ....
    - 而二次探测探测的步长就变成原来的“二次方”, 也就是说,它探测的下标序列就是 hash(key) + 0, hash(key) + (1 ^ 2), hash(key) + (2 ^ 2)
  - 双重散列(Double hashing)
    - 不仅要使用一个散列函数。我们使用一组散列函数 hash1(key), hash2(key), hash3(key)
    - 我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列，依次类推找到空闲的存储位置
  - 装载因子(load factor)
    - 不管采用那种方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高
    - 为了尽可能保证散列表的操作效率，一般情况下，我们会尽快保证散列表中有一定比例的空闲槽位
    - 状态因子概述及公式
      - 散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
      - 装载因子来表示空位多少，状态因子越大，说明空闲位置越少，冲突越多，散列表的性能就会下降
- 链表法
  - 在散列表中，每个"桶(bucket)" 或者"槽(slot)" 会对应一条链条，所以散列值相同的元素我们都会放在相同槽位对应的链表中
  - 当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度O(1)
  - 当查找删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或删除。那查找或删除操作的时间复杂度是多少呢？
    - 实际上，这两个操作的时间复杂度跟链表的长度k成正比，也就是O(k)
    - 对于散列比较均匀的散列函数来说，理论上讲, k = n / m,其中n表示散列中数据个数，m表示散列中“槽”的个数
#### 资料参考
- [[Data Structure & Algorithm] Hash那点事儿](https://www.cnblogs.com/maybe2030/p/4719267.html)