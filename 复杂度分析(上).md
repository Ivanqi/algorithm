# 大O复杂度表示法
## 例子1
```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```
- 代码的 `int sum = 0`和 `int i = 1`需要1个unit_time的执行时间
- 遍历那部分的代码，需要执行n遍，所以需要2n*untime_time的执行时间
- 所以整个代码的总的执行时间就是(2n + 2) * unit_time
- 可以看出,`所有代码的执行时间T(n)与每行代码的执行次数成正比`

## 例子2
```
 int cal(int n) {
   int sum = 0; // 1个unit_time
   int i = 1;   // 1个unit_time
   int j = 1;   // 1个unit_time
    for (; i <= n; ++i) {   // 执行n遍,需要2n*unit_time
        j = 1;
        for (; j <= n; ++j) {   // 执行n^2遍，需要2(n^2) * unit_time
            sum = sum +  i * j;
        }
    }
 }
```
- 整段代码总的执行时间: T(n) = (2(n ^ 2) + 2n + 3) * unit_time

## 规律
### 所有代码的执行时间T(n)与每行代码执行次数n成正比
- 把这个规律总结成一个公式: T(n) = O(f(n))
- T(n)，代表代码执行时间
  - n表示数据规模的大小
  - f(n) 表示每行代码执行的次数总和，因为这是一个公式，所以用f(n)来表示
- 公式中的O，表示代码执行时间T(n) 与 f(n)表达式成正比
  
### 大O时间复杂度表示法
- 所以，第1个例子中的T(n) = O(2n + 2), 第2个例子中的T(n) = O(2(n^2) + 2n + 3)
- 这就是大O时间复杂度表示法
- 大O时间复杂度并不具体代表代码真正的执行时间，而是表示`代码执行时间随数据规模增长的变化趋势`，所以，也叫做`渐进时间复杂度(asymptotictime complexity), 简称时间复杂度`

# 时间复杂度
## 只关注循环执行次数最多的一段代码
```
int cal(int n) {
    int sum = 0;
    int i = 1;
    for (; i <= n; ++i) {
        sum = sum + i;
    }
    return sum;
    }
```
- `在分析一个算法、一段代码的时间复杂度的时候，也只关注循环次数最多的那一段代码就可以了`
- int sum = 0;、int i = 1; 是常量级别代码与n的大小无关，所以对复杂度没有影响
- 循环才是代码分析的重点，循环代码被执行n次，所以总的时间复杂度为O(n)

## 加法法则: 总复杂度等于量级最大的那段代码的复杂度
```
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
}
```
- 代码分成三部分，分别是求sum_1、sum_2、sum_3。可以分析每一部分的时间复杂度，然后把它们放到一起，再取一个量级最大的作为整段的复杂度
- 第一段的时间复杂度是多少？
  - 这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关
  - 即便代码循环10000次，还是1000000，只要是一个已知的数，跟n无关，照样也是常量级的执行时间
  - 尽管对代码的执行时间会很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所有不管常量的执行时间多大，都可以忽略。因为它本身对增长趋势并没有影响
- 第2段和第3段代码的时间复杂度: O(n) 和 O(n ^ 2)
- 综合这三段代码的时间复杂度，取其中最大的量级。所以，整段代码的时间复杂度为O(n ^ 2)。也就是说：`总的时间复杂度就等于量级最大的那段代码的时间复杂度`
- 公式
  - T1(n) = O(f(n))
  - T2(n) = O(g(n))
  - 那么T(n) = T1(n) + T2(n) = max(O(f(n))), O(g(n)) = O(max(f(n), g(n)))

## 乘法法则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
### 公式
- 如果T1(n) = O(f(n)), T2(n) = O(g(n))
- 那么 T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))
- 也就是说，假设T1(n) = O(n), T2(n) = O(n ^ 2),则T1(n) * T2(n) = O(n ^ 3)

#### 例子
```
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
} 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
}
```
- 假设f()只是一个普通的操作，循环部分代码的时间复杂度为T1(n) = O(n)
- 但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n),所以，整个call函数的时间复杂度就是, T(n) = T1(n) * T2(n) = O(n * n) = O(n ^ 2)

# 常见的时间复杂度
## O(1)
```
int i = 8;
int j = 6;
int sum = i + j;
```
- O(1)只是常量时间的复杂度的一种表示方法，并不是指执行了一行代码
- 上面的代码，即便3行，它的时间复杂度也是O(1)，而不是O(3)
- `一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)`

## O(logn)、O(nlogn)
### O(logn)
```
i=1;
while (i <= n)  {
    i = i * 2;
}
```
- 对数时间复杂度非常常见，同时也是最难分析的一种时间复杂度
- 根据前面的分析方法，第3行代码是循环次数最多的。所以，只要能计算出这行代码被执行了多少次，就能直到整段代码的时间复杂度
- 从代码中可以看出，变量i的值从1开始取，每循环一次就乘以2，当大于n时，循环结束
- 实际上，变量i的取值就是一个等比数列
  - 2 ^0、2 ^ 1、2 ^ 2、... 、2 ^ k、... 、 2 ^ x = n
- 所以，只要知道x值是多少，就知道这行代码执行的次数了。通过2 ^ x = n求解，等于 x = log2n。所以这段代码的时间复杂度就是O(log2n)
  
### O(nlogn)
- 还记得刚讲过的乘法法则吗？如果一段代码的时间复杂度是O(logn)，循环执行n遍，时间复杂度就是O(nlogn)
- O(nlogn)也是一种非常常见的算法时间复杂度，比如，归并排序、快速排序的时间复杂度都是O(nlogn)

## O(m + n) 和 O(m * n)
```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```
- 代码的复杂度是由2个数据的规模来决定的
- 从代码中可以看出，m和n是表示两个数据规模。无法事先评估m和n谁的量级大，所以在表示复杂度的时，就不能简单利用加法法规，省略掉其中一个，所以上面代码的时间复杂度就是O(m + n)
- 针对这种情况，原来的加法法则就不正确了，需要将加法规则改为T1(m) + T2(n) = O(f(m) + g(n))
- 但乘法法则继续有效: T1(m) * T2(n) = O(f(m) * f(n))

# 空间复杂度分析
- 时间复杂度的全称是`渐进时间复杂度，表示算法的执行时间与数据规模之间的增长`
- 空间复杂度全称就是`渐进空间复杂度(asymptotic space complexity)`, 表示算法的存储空间与数据规模之间的增长关系
```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```
- 跟时间复杂度分析一样，在第2行代码中，申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系
- 第3行申请了一个大小为n的int类型数据，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度为O(n)