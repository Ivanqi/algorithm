#### BF 算法
- BF 算法中的BF 是Brute Force的缩写，中文叫做暴力匹配法，也叫朴素匹配算法
- ![avatar](images/../../images/string_matching_1.png)
- 作为最简单，最暴力的字符串匹配算法，BF算法的思想可以用一句话来概括，那么就是`在主串中，检查起始位置分别是0, 1, 2 ... n - m 且长度为m的n - m + 1个子串，看有没有跟模式串匹配` 
- 时间复杂度
  - O(n * m)

#### RK 算法
- RK 叫做 Rabin-Karp算法，BF的升级版算法
- BF 算法的缺陷
  - BF算法。如果模式长度为m,主串长度为n,那么主串中，就会有 n - m + 1个长度为m的子串
  - 每次检查主串与子串是否匹配，需要依次对比每个字符，所以BF算法的时间复杂度比较高, `O(n * m)`
- RK算法思路
  - 通过哈希算法对主串的 n - m + 1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小
  - 如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式匹配了
  - ![avatar](images/../../images/string_matching_2.png)
  - 不过，通过哈希算法计算子串的哈希值的时候，需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是算法整体效率没有提升
  - 假设要匹配的字符串的字符集中包含K个字符，可以用一个K进制来表示一个子串，这个K进制转化成十进制，作为子串的哈希值
    - ![avatar](images/../../images/string_matching_3.png)
    - 比如要处理的字符串只包含 a ~ z这26个小写字母，那我们就用26进制来表示一个字符串
    - 在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应二十六进制，一个包含a到z这个26个字符的字符串，计算哈希的时候，只需要把进位从10改成26
  - 这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系
    - ![avatar](images/../../images/string_matching_4.png)
    - ![avatar](images/../../images/string_matching_5.png)
    - 相邻两个子串`s[i - 1]` 和 `s[i]` (子串长度都是m), 对应的哈希值计算公式有交集，也就是说，可以使用s[i - 1]的哈希值很快的计算出s[i]的哈希值
  - 时间复杂度
    - 计算子串哈希值
      - 通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值，这部分的时间复杂度`O(n)`
    - 模式串哈希值与子串哈希值之间比较
      - 模式串与单个子串哈希值之间的比较的时间复杂是`O(1)`
      - 有 n - m + 1 个子串需要比较，所以时间复杂度为`O(n)`
    - 总体时间复杂度: `O(n)`
    - 极端情况
      - 如果存在大量的冲突，就会导致RK算法时间复杂度退化，效率下降
      - 时间复杂度为`O(n * m)`

#### 参考资料
- [BF算法（串模式匹配算法）C语言详解](http://data.biancheng.net/view/179.html)
- [字符串匹配算法（BF & RK）](https://blog.csdn.net/qq_21201267/article/details/92695636)