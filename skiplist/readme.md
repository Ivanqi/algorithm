#### 快表
- 基本实现
  - 每次插入数据的时候，随机产生的level，决定了新节点的层数
  - 数组update的作用，用于存储新节点所有层数上，各自的前一个节点的信息
  - 节点内的forwards数组，用以存储该节点所有层的下一节点的信息
  - 当所有节点的最大层数变量maxlevel = 1的时候，跳表退化成一个普通的链表
#### randomlevel
- 流程演示
  - ![avatar](images/../../images/skiplist_1.png)   
- 计算过程
  - 首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）
  - 如果一个节点有第i层(i>=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p
  - 节点最大的层数不允许超过一个最大值，记为MaxLevel
  - 伪代码
    ```
    // p = 1/4 , MaxLevel = 32
    randomLevel()
        level := 1
        // random()返回一个[0...1)的随机数
        while random() < p and level < MaxLevel do
            level := level + 1
        return level
    ``` 
  - 算法性能分析
    - 根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低.定量的分析如下
      - 节点层数至少为1。而大于1的节点层数，满足一个概率分布。
      - 节点层数恰好等于1的概率为1-p。
      - 节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。
      - 节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。
      - 节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。
    - 因此，一个节点的平均层数（也即包含的平均指针数目），计算如下
      - ![avatar](images/../../images/skiplist_2.png)   
    - 现在很容易计算出：
      - 当p=1/2时，每个节点所包含的平均指针数目为2；
      - 当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。