#### 链表排序注意点
- 一般而言，考虑只能改变节点位置，冒泡排序相比于数据实现，比较次数一致，但交换时操作更复杂
- 插入排序，不需要再有后移操作，找到位置直接插入，但排序完毕后可能需要倒置链表
- 选择排序比较次数一致，交换操作同样比较麻烦
- 综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系统会减小，选择排序无明显变化

#### 归并排序
##### 时间复杂度
-  在递归那一节说过，递归的适用场景是，一个问题a可以分解为多子问题a,b,c，那求解问题a就可以分解问题b，c
-  问题b，c解决之后，我们再把b, c的结果合并成a的结果
-  如果我们定义求解问题a的时间是T(a),求解问题b,c的时间分别是T(b), T(c)，那我们就可以得到这样的递推关系式
    ```
    T(a) = T(b) + T(c) + K
    ```
    - 其中K等于将两个子问题b, c的结果合并成问题a的结果所消耗的时间

- 从刚刚的分析，我们可以得到一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式
- 套用这个公式，我们来分析一下归并排序的时间复杂度
- 我们假设n个元素进行归并排序需要的时间是T(n)，那分解成两个子数组排序时间都是T(n/2)
- 我们知道，merege()函数合并两个有序子数组的时间复杂度O(n)
- 所以，套用前面的公式，归并排序的时间复杂度的计算公式就是
    ```
    T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。
    T(n) = 2*T(n/2) + n； n>1
    ```
    - 通过这个公式，如何来求解T(n)呢？还不够直观？那我们再进一步分解计算过程
    ```
    T(n) = 2*T(n/2) + n
        = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
        = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
        = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
        ......
        = 2^k * T(n/2^k) + k * n
        ......
    ```
    - 通过这样一步一步分解推导，我们可以得到T(n) = 2^k * T(n/2^k) + k * n
    - 当 T(n/2^k) = T(1)时，也就是 n/2^k = 1, 我们得到 k=log2n
    - 我们将k值代入上面的公式，得到T(n)=Cn+nlog2n
    - 如果我们用大O标记法来表示的话,T(n)就等于O(nlogn)
    - 所以归并排序的时间复杂度是O(nlogn)

#### 快速排序
##### 时间复杂度
- 快排也是用递归实现的。对于递归代码的时间复杂度，前面总结的公式，这里也是适用的
- 如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递归求解公式跟归并排序是相同的，所以快排的时间复杂度也是O(nlogn)
    ```
    T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。
    T(n) = 2*T(n/2) + n； n>1
    ```
- 但是，公式成立的前提是每次分区操作，我们选择的pivot都很合适，正好能将大区间对等地一分为二。但实际这种情况是很难实现的
- 举一个极端的例子。如果数组中的数据原来已经是有序的，比如1，3，5，6，8。
- 如果我们每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的
- 我们需要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n / 2个元素，这种情况下，快排的时间复杂度就从O(nlogn)退化成了O(n ^ 2)
- 我们刚刚讲了两个极端下的时间复杂度，一个是分区及其均衡，一个是分区极其不均衡。它们分别对应快排的最好时间复杂度和最坏情况时间复杂度。那快排的平均情况时间是多少呢？
  - 我们假设每次分区操作都将分区分成大小为9:1的两个小分区。我们继续套用递归时间复杂度的递推公式，就会变成这样
    ```
    T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。

    T(n) = T(n/10) + T(9*n/10) + n； n>1
    ```