#### 归并排序
##### 时间复杂度
-  在递归那一节说过，递归的适用场景是，一个问题a可以分解为多子问题a,b,c，那求解问题a就可以分解问题b，c
-  问题b，c解决之后，我们再把b, c的结果合并成a的结果
-  如果我们定义求解问题a的时间是T(a),求解问题b,c的时间分别是T(b), T(c)，那我们就可以得到这样的递推关系式
    ```
    T(a) = T(b) + T(c) + K
    ```
    - 其中K等于将两个子问题b, c的结果合并成问题a的结果所消耗的时间

- 从刚刚的分析，我们可以得到一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式
- 套用这个公式，我们来分析一下归并排序的时间复杂度
- 我们假设n个元素进行归并排序需要的时间是T(n)，那分解成两个子数组排序时间都是T(n/2)
- 我们知道，merege()函数合并两个有序子数组的时间复杂度O(n)
- 所以，套用前面的公式，归并排序的时间复杂度的计算公式就是
    ```
    T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。
    T(n) = 2*T(n/2) + n； n>1
    ```
    - 通过这个公式，如何来求解T(n)呢？还不够直观？那我们再进一步分解计算过程
    ```
    T(n) = 2*T(n/2) + n
        = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
        = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
        = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
        ......
        = 2^k * T(n/2^k) + k * n
        ......
    ```
    - 通过这样一步一步分解推导，我们可以得到T(n) = 2^k * T(n/2^k) + k * n
    - 当 T(n/2^k) = T(1)时，也就是 n/2^k = 1, 我们得到 k=log2n
    - 我们将k值代入上面的公式，得到T(n)=Cn+nlog2n
    - 如果我们用大O标记法来表示的话,T(n)就等于O(nlogn)
    - 所以归并排序的时间复杂度是O(nlogn)